1. 什么是数据结构？
	数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科.
	程序设计 = 数据结构 + 算法
	传统上，我们把数据结构分为逻辑结构和物理结构。
	逻辑结构：是指数据对象中数据元素之间的相互关系，也是我们今后最需要关注和讨论的问题。
	{
		集合结构(仅仅同属一个集合),线性结构（一对一的关系），　树形结构（一对多的层次关系），　图形结构（多对多的关系）
	}
	物理结构：是指数据的逻辑结构在计算机中的存储形式。
	｛
		顺序存储：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。例如我们编程语言的数组结构就是这样滴。
		链式存储：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。（因此需要用一个指针存放数据元素的地址，这样子通过地址就可以找到相关联数据元素的位置。）
	｝
2. 算法
	算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

	算法的特征：输入、输出、有穷性、确定性和可行性。
	输入：算法具有零个或多个输入。
	输出：算法至少有一个或多个输出。
	有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
	确定性：算法的每一个步骤都具有确定的含义，不会出现二义性。
	可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

	算法设计的要求：
	正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。
	大体分为以下四个层次：
    算法程序没有语法错误。
    算法程序对于合法输入能够产生满足要求的输出。
    算法程序对于非法输入能够产生满足规格的说明。
    算法程序对于故意刁难的测试输入都有满足要求的输出结果。
	可读性：算法设计另一目的是为了便于阅读、理解和交流。
	健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常、崩溃或莫名其妙的结果。
	时间效率高和存储量低：
３. 时间复杂度和空间复杂度
	```
	int i, sum = 0, n = 100;   // 执行1次
	for( i=1; i <= n; i++ )    // 执行了n+1次
	{
    	sum = sum + i;         // 执行n次
	}
	```
	```
	int sum = 0, n = 100;     // 执行1次
	sum = (1+n)*n/2;          // 执行1次
	```
	第一种算法执行了1+(n+1)+n=2n+2次。
	第二种算法，是1+1=2次
	我们研究算法的复杂度，侧重的是研究算法随着输入规模扩大增长量的一个抽象，而不是精确地定位需要执行多少次。
	我们在分析一个算法的运行时间时，重要的是把基本操作的数量和输入模式关联起来。
	函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大。那么，我们说f(n)的增长渐近快于g(n)。
	判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高项）的阶数。
	算法时间复杂度的定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。
	算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。
	它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。
	这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。
	一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。
	显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为O(1)，O(n)，O(n^2)。

	推导大O阶方法:
	用常数1取代运行时间中的所有加法常数。
	在修改后的运行次数函数中，只保留最高阶项。
	如果最高阶项存在且不是1，则去除与这个项相乘的常数。
	得到的最后结果就是大O阶。
	线性阶:一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长。
	平方阶:
	对数阶:
	在应用中，这是一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。

	算法的空间复杂度:
	算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。
4. 线性表
	线性表（List）：由零个或多个数据元素组成的有限序列。
	首先它是一个序列，也就是说元素之间是有个先来后到的
	若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继。
	另外，线性表强调是有限的，事实上无论计算机发展到多强大，它所处理的元素都是有限的。
	若将线性表记为（a1,…,ai-1,ai,ai+1,…an）,则表中ai-1领先于ai,ai领先于ai+1,称ai-1是ai的直接前驱元素,ai+1是ai的直接后继元素。
	所以线性表元素的个数n(n>=0)定义为线性表的长度，当n=0时，称为空表。

	第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继。

	数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。
	{
		原子类型：不可以再分解的基本类型，例如整型、浮点型、字符型等。
		结构类型：由若干个类型组合而成，是可以再分解的，例如整型数组是由若干整型数据组成的。
	}
	抽象：是指抽取出事物具有的普遍性的本质。它要求抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节。
	我们对已有的数据类型进行抽象，就有了抽象数据类型。
	抽象数据类型（Abstract Data Type，ADT）是指一个数学模型及定义在该模型上的一组操作。
	抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。
	“抽象”的意义在于数据类型的数学抽象特性。
	描述抽象数据类型的标准格式：
	ADT 抽象数据类型名
	Data
    数据元素之间逻辑关系的定义
		Operation
    操作
	endADT

	所谓抽象数据类型就是把数据类型和相关操作捆绑在一起。
	总结下，顺序存储结构封装需要三个属性:
	存储空间的起始位置，数组data，它的存储位置就是线性表存储空间的存储位置。
	线性表的最大存储容量：数组的长度MaxSize。
	线性表的当前长度：length。

	数组的长度是存放线性表的存储空间的总长度，一般初始化后不变。
	而线性表的当前长度是线性表中元素的个数，是会变化的。

	线性表顺序存储结构的优缺点:
	线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1)。而在插入或删除时，时间复杂度都是O(n)。
	优点：
	无须为表示表中元素之间的逻辑关系而增加额外的存储空间。
	可以快速地存取表中任意位置的元素。
	缺点：
	插入和删除操作需要移动大量元素。
	当线性表长度变化较大时，难以确定存储空间的容量。
	容易造成存储空间的“碎片”。

	线性表链式存储结构定义:
	线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置。比起顺序存储结构每个数据元素只需要存储一个位置就可以了。
	单链表:
	现在链式存储结构中，除了要存储数据元素信息外，还要存储它的后继元素的存储地址（指针）。
	也就是说除了存储其本身的信息外，还需存储一个指示其直接后继的存储位置的信息。
	我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。
	指针域中存储的信息称为指针或链。
	这两部分信息组成数据元素称为存储映像，称为结点(Node)。
	n个结点链接成一个链表，即为线性表(a1, a2, a3, …, an)的链式存储结构。
	因为此链表的每个结点中只包含一个指针域，所以叫做单链表。
	我们把链表中的第一个结点的存储位置叫做头指针，最后一个结点指针为空(NULL)。

	头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。
	头指针具有标识作用，所以常用头指针冠以链表的名字（指针变量的名字）。
	无论链表是否为空，头指针均不为空。
	头指针是链表的必要元素。

	头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度）。
	有了头结点，对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了。
	头结点不一定是链表的必须要素。
	获得链表第i个数据的算法思路：
	声明一个结点p指向链表第一个结点，初始化j从1开始；
	当j<i时，就遍历链表，让p的指针向后移动，不断指向一下结点，j+1；
	若到链表末尾p为空，则说明第i个元素不存在；
	否则查找成功，返回结点p的数据。
	其核心思想叫做“工作指针后移”，这其实也是很多算法的常用技术。
